from dataclasses import dataclass, field
from typing import TYPE_CHECKING, Any

__all__ = [
    'Delta',
    'GeneratedDelta',
    'EndGen',
    'EndGenEOS',
    'EndGenMaxTokens',
    'EndGenStopToken',
    'EndGenObjectTypes',
    'EndGenCallableTypes',
]


if TYPE_CHECKING:
    from com.constraints import *
    from com.roles import *


@dataclass
class Delta:
    """A delta in a string."""

    id: str
    name: 'GenRole'
    content: str | None = None
    usage: dict[str, Any] | None = None

    def get_end[T: EndGen](self, cls: type[T]) -> T | None:
        if isinstance(self, GeneratedDelta):
            if isinstance(self.end, cls):
                return self.end
        return None


_default_end_gen = lambda: EndGenEOS()


@dataclass
class GeneratedDelta(Delta):
    """
    A delta in a string generated by an LLM.
    """

    end: 'EndGen' = field(default_factory=_default_end_gen)
    constraints: list['Constraint'] = field(default_factory=list)
    reasoning_content: str | None = None
    annotations: dict[str, Any] | None = None
    audio: dict[str, Any] | None = None
    refusal: str | None = None


@dataclass
class EndGen:
    """End of generation."""


@dataclass
class EndGenEOS(EndGen):
    """End of generation stream."""


@dataclass
class EndGenMaxTokens(EndGen):
    """End of generation because maximum number of tokens reached."""

    constraint: 'MaxTokensConstraint'


@dataclass
class EndGenStopToken(EndGen):
    """End of generation because stop token reached."""

    constraint: 'StopTokenConstraint | None'
    filtered: bool = False


# for now, jsonmode is disabled, so these dummy classes preserve old code


class EndGenObjectTypes(EndGen):
    constraint: Any
    content: Any


class EndGenCallableTypes(EndGen):
    constraints: list[Any]
    ids: list[Any]
    content: list[Any]
    results: Any
